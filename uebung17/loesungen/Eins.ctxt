#BlueJ class context
comment0.target=Eins
comment0.text=\r\n\ Klasse\ fuer\ ueb\ 17\ mit\ integriertem\ TestDialog\r\n\ \r\n\ @author\ VENET\ Aurianne\ &\ SCHALL\ Hanna\r\n\ @version\ 1.0\r\n
comment1.params=i
comment1.target=int\ apply(int)
comment10.params=i\ j\ fkt
comment10.target=void\ executeACl(int,\ int,\ int)
comment10.text=\r\n\ executeACl\ Methode\r\n\ \ \ \ \ \ methode\ die\ die\ AnonymenKlasse\ als\ funktion\ benutzt\r\n\ @param\ i\ ein\ Integer\r\n\ @param\ j\ ein\ Integer\r\n\ @param\ fkt\ funktion\ die\ auf\ die\ Zahlen\ angewendet\ wird\r\n
comment11.params=i\ j
comment11.target=void\ executeFakultaetTopLevel(int,\ int)
comment11.text=\r\n\ executeFakultaetTopLevel\ Methode\ arbeitet\ wie\ applyAndPrint\ \r\n\ nur\ mit\ TopLevel-Implementierung\ und\ nur\ fuer\ Fakultaet\r\n\r\n\ @param\ i\ obere\ Grenze\r\n\ @param\ j\ untere\ Grenze\r\n
comment12.params=i\ j
comment12.target=void\ executeFakultaetStaticNestedCl(int,\ int)
comment12.text=\r\n\ Methode\ executeFakultaetStaticNestedCl\ arbeitet\ wie\ applyAndPrint\ \r\n\ nur\ mit\ StaticNestedClass-Implementierung\ und\ nur\ fuer\ Fakultaet\r\n\r\n\ @param\ i\ untere\ Grenze\r\n\ @param\ j\ obere\ Grenze\r\n
comment13.params=msg
comment13.target=int\ inputInt(java.lang.String)
comment13.text=\r\n\ Methode\ inputInt\ zum\ Einlesen\ eines\ int-Wertes\r\n\r\n\ @param\ msg\ Aufforderung\ zur\ Eingabe\r\n\ @return\ Der\ R\u00FCckgabewert\r\n
comment14.params=i\ j
comment14.target=void\ executeE(int,\ int)
comment14.text=\r\n\ Methode\ executeE\ ruft\ die\ Methode\ applyAndPrint\ (siehe\ oben)\r\n\ mit\ einem\ Lambda-Ausdruck\ auf,\ welcher\ f\u00FCr\ gerade\ Zahlen\ die\ Quadratzahl\ berechnet\r\n\r\n\ @param\ i\ untere\ Grenze\r\n\ @param\ j\ obere\ Grenze\r\n
comment15.params=i\ j
comment15.target=void\ executeF(int,\ int)
comment15.text=\r\n\ Methode\ executeF\ ruft\ die\ Methode\ \r\n\ applyAndPrint\ mit\ einem\ Lambda-Ausdruck\ auf,\ welcher\ prueft,\ ob\ die\ Fakultaet\ einer\ gegebenen\ Zahl\ ungeradeist.\r\n\ Ist\ dies\ der\ Fall,\ wird\ die\ Fakultaet\ zurueckgegeben,\ ansonsten\ 0\r\n\r\n\ @param\ i\ untere\ Grenze\r\n\ @param\ j\ obere\ Grenze\r\n
comment16.params=args
comment16.target=void\ main(java.lang.String[])
comment16.text=\r\n\ Methode\ main\ legt\ ein\ neues\ Objekt\ der\ Klasse\ an\ und\ startet\ das\ Programm\r\n\r\n\ @param\ args\r\n
comment17.params=
comment17.target=java.lang.String\ toString()
comment17.text=\r\n\ Methode\ toString\ informiert\ ueber\ die\ Klasse\r\n\r\n\ @return\ Info-String\r\n
comment2.params=i
comment2.target=int\ apply(int)
comment3.params=i
comment3.target=int\ apply(int)
comment4.params=i
comment4.target=int\ apply(int)
comment5.params=n
comment5.target=boolean\ test(int)
comment6.params=
comment6.target=Eins()
comment6.text=\r\n\ Konstruktor\r\n\r\n
comment7.params=i\ j\ f
comment7.target=void\ applyAndPrint(int,\ int,\ MyFunction)
comment7.text=\r\n\ applyAndPrint\ Methode\ gibt\ eine\ Liste\ mit\ Ergebnissen\ aus,\ die\ entstehen\ wenn\ man\ die\ Funktion\ f\ auf\ alle\ int-Zahlen\ zwischen\ i\ und\ j\ anwendet\r\n\r\n\ @param\ f\ Funktion\r\n\ @param\ i\ untere\ Grenze\ (ausgeschlossen)\r\n\ @param\ j\ obere\ Grenze\ (ausgeschlossen)\r\n\ anwendet.\r\n
comment8.params=
comment8.target=void\ start()
comment8.text=\r\nHauptschleife\ des\ Testprogramms\r\n
comment9.params=i\ j\ fkt
comment9.target=void\ executeLambda(int,\ int,\ int)
comment9.text=\r\n\ executeLambda\ Methode\r\n\ \ \ \ \ \ methode\ die\ die\ Lambda\ Ausdruck\ als\ funktion\ benutzt\r\n\ @param\ i\ ein\ Integer\r\n\ @param\ j\ ein\ Integer\r\n\ @param\ fkt\ funktion\ die\ auf\ die\ Zahlen\ angewendet\ wird\r\n
numComments=18
